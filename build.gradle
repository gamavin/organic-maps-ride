// Root build.gradle â€” konfigurasi umum semua subproject

plugins {
    id 'com.android.application' apply false
    id 'com.android.library'     apply false
    id 'org.jetbrains.kotlin.android'          apply false
    id 'org.jetbrains.kotlin.plugin.parcelize' apply false
    // Versi plugin ditentukan di settings.gradle (pluginManagement)
}

// Utility eksekusi proses eksternal (dipakai ambil versionCode/Name)
def run(cmd) {
    def output = providers.exec { commandLine = cmd }
    return output.standardOutput.asText.get().trim()
}

// Ambil versi dari script bash (support Windows & *nix) tanpa API internal Gradle
def getVersion() {
    def isWindows = System.getProperty('os.name').toLowerCase().contains('windows')
    // Kandidat lokasi bash di Windows; di *nix cukup 'bash'
    def bashCandidates = isWindows ? [
            'C:\\Program Files\\Git\\bin\\bash.exe',
            'C:\\Program Files (x86)\\Git\\bin\\bash.exe',
            'bash'
    ] : ['bash']

    def bash = bashCandidates.find { path ->
        path == 'bash' || new File(path).exists()
    }
    if (bash == null) {
        throw new GradleException("Tidak menemukan 'bash'. Pastikan Git for Windows terpasang atau 'bash' ada di PATH.")
    }

    def scriptPath = "${rootDir}/tools/unix/version.sh"
    if (!file(scriptPath).exists()) {
        logger.warn("tools/unix/version.sh tidak ditemukan, memakai versi default 1.0")
        return new Tuple2(1, "1.0")
    }

    def versionCode = Integer.parseInt(run([bash, scriptPath, 'android_code']))
    def versionName = run([bash, scriptPath, 'android_name'])
    return new Tuple2(versionCode, versionName)
}

// Ekspor ke seluruh subproject
rootProject.ext {
    def ver = getVersion()
    versionCode = ver.V1
    versionName = ver.V2
}
